<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>this | polly'blog</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/." class="title">polly'blog</a><span class="subtitle"></span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>this</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2018-08-05</div></div></div><article><div class="container post"><p>JavaScript中的this是在运行时进行绑定的，不是在编写时绑定。<br>换句话说，this的绑定和函数声明的位置无关，和函数的调用位置有关。</p>
<h2 id="1-this的定义"><a href="#1-this的定义" class="headerlink" title="1 this的定义"></a>1 this的定义</h2><p>JavaScript中的函数被调用时，会创建一个活动记录（也称为执行上下文），该记录会包含函数的调用栈、调用方法、参数等信息，<br>this就是用来记录的其中一个属性，会在函数执行的过程中用到。JavaScript中的this机制比较复杂，它提供了一种方式来隐式“传递”一个对象引用。</p>
<p>在JavaScript中，函数比较特殊，也属于对象，因此<strong>函数也能在内部使用this引用自身</strong>，有两种情况，递归和调用自身后解除绑定。</p>
<p>递归示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo(num) &#123;</span><br><span class="line">  consol.log(&quot;foo: &quot; + num);</span><br><span class="line">  this.count++;</span><br><span class="line">&#125;</span><br><span class="line">foo.count = 0;</span><br><span class="line">var i;</span><br><span class="line">for(i=0; i&lt;10; i++)&#123;</span><br><span class="line">  if(i&gt;5)</span><br><span class="line">  	foo.call(foo,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-this的绑定方式"><a href="#2-this的绑定方式" class="headerlink" title="2 this的绑定方式"></a>2 this的绑定方式</h2><p>函数在执行过程中的调用位置决定this的绑定对象。this的绑定方式有以下几种：</p>
<h3 id="2-1-默认绑定"><a href="#2-1-默认绑定" class="headerlink" title="2.1 默认绑定"></a>2.1 默认绑定</h3><p>在全局中调用独立函数，this指向全局对象。下例中，函数的调用位置和变量 <strong>a</strong> 平级，同属于全局对象，this.a 则指向全局属性<strong>a</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">  console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">var a = 2;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<h3 id="2-2-隐式绑定"><a href="#2-2-隐式绑定" class="headerlink" title="2.2 隐式绑定"></a>2.2 隐式绑定</h3><p>根据调用位置是否有上下文来判断，或者说是否被某个对象包含。当函数引用有上下文对象时，隐式绑定则会把函数中调用的this绑定到这个上下文对象，如下例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">  console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line"> a:2,</span><br><span class="line"> foo:foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo()；</span><br></pre></td></tr></table></figure></p>
<p><strong>对象属性引用链中只有最顶层或者最后一层会影响调用位置</strong>。猜猜👇下面的代码<code>obj1.obj2.foo()</code>终会输出什么。调用foo()函数的最后一层对象时obj2，因此foo函数中的this指向obj2。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">var obj2 = &#123;</span><br><span class="line">  a: 2,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line">var obj1 = &#123;</span><br><span class="line">  a: 3,</span><br><span class="line">  obj2: ojb2</span><br><span class="line">&#125;</span><br><span class="line">obj1.obj2.foo()</span><br></pre></td></tr></table></figure></p>
<p><strong>隐式丢失</strong>： 然而，<strong>对象不拥有函数</strong>，<strong>函数也不属于对象</strong>。某种情况下，被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把this绑定到全局对象或者undefined上。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 2,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line">var a = 3;</span><br><span class="line">var bar = obj.foo;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure></p>
<h3 id="2-3-显示绑定"><a href="#2-3-显示绑定" class="headerlink" title="2.3 显示绑定"></a>2.3 显示绑定</h3><p>使用函数的call()、apply()方法，第一个参数传入的是对象，即会把函数中的this绑定到对象上，接着在调用函数时指定这个对象。因为可以指定函数的对象，所以这个过程称为显示绑定。</p>
<h4 id="2-3-1-硬绑定"><a href="#2-3-1-硬绑定" class="headerlink" title="2.3.1 硬绑定"></a>2.3.1 硬绑定</h4><p>显示绑定无法解决丢失绑定问题，解决方法是在一个函数A中强制绑定到某个对象。那么函数A在以后的执行中this始终指向那个对象，无法再改变。这种绑定时一种显示的强制绑定，称为硬绑定。<br>典型应用是创建一个包裹函数，传入所有的参数并返回接收到的所有值，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function foo(something) &#123;</span><br><span class="line">  console.log(this.a, something)</span><br><span class="line">  return this.a + something</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 2</span><br><span class="line">&#125;</span><br><span class="line">var bar = function() &#123;</span><br><span class="line">  return foo.apply(obj,arguments);</span><br><span class="line">&#125;</span><br><span class="line">var b = bar(3);</span><br><span class="line">console.log(b)</span><br></pre></td></tr></table></figure></p>
<p>上例代码中的<code>function(foo, obj){return foo.apply(obj,arguments)}</code>（加了了两个参数），可以使用ES5中的内置方法Function.prototype.bind()进行替代，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo(something) &#123;</span><br><span class="line">  console.log(this.a, something)</span><br><span class="line">  return this.a + something</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 2</span><br><span class="line">&#125;</span><br><span class="line">var bar = foo.bind(obj)</span><br><span class="line">var b = bar(3);</span><br></pre></td></tr></table></figure></p>
<p>bind(…)会返回一个硬编码函数，它会把参数设置为this的上下文并调用原始函数。</p>
<h4 id="2-3-2-API执行上下文"><a href="#2-3-2-API执行上下文" class="headerlink" title="2.3.2 API执行上下文"></a>2.3.2 API执行上下文</h4><p>JavaScript中的内置函数，提供了一个可选的参数，通常被称为“上下文”，确保回调函数使用指定的this。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo(el) &#123;</span><br><span class="line">  console.log(el, this.id)</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  id: &quot;awesome&quot;</span><br><span class="line">&#125;</span><br><span class="line">[1,2,3].forEach(foo, obj);</span><br></pre></td></tr></table></figure></p>
<p>猜猜上面输出是什么？动手试一下吧！</p>
<h3 id="2-4-new-绑定"><a href="#2-4-new-绑定" class="headerlink" title="2.4 new 绑定"></a>2.4 new 绑定</h3><p>使用new构造函数，会经历以下操作：<br>a、创建一个对象<br>b、该对象被执行[[prototype]]链接<br>c、对象绑定到this<br>d、函数中如果没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">  this.a = a;</span><br><span class="line">&#125;</span><br><span class="line">var bar = new foo(2);</span><br><span class="line">console.log(bar.a)</span><br></pre></td></tr></table></figure>
<h3 id="2-5-this绑定的优先级"><a href="#2-5-this绑定的优先级" class="headerlink" title="2.5 this绑定的优先级"></a>2.5 this绑定的优先级</h3><p>new绑定 &gt; call.apply或者硬绑定 &gt; 隐式绑定 &gt; 默认绑定</p>
<h3 id="2-6-其他绑定"><a href="#2-6-其他绑定" class="headerlink" title="2.6 其他绑定"></a>2.6 其他绑定</h3><h4 id="2-6-1-被忽略的this"><a href="#2-6-1-被忽略的this" class="headerlink" title="2.6.1 被忽略的this"></a>2.6.1 被忽略的this</h4><p>把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值会被忽略，应用默认的绑定规则。<br>call的绑定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">  console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">var a = 2;</span><br><span class="line">foo.call(null)</span><br></pre></td></tr></table></figure></p>
<p>apply的绑定：常用来“展开”一个数组，并当作参数传入一个函数。<br>bind的绑定： 可以用来对参数进行柯里化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo(a,b)&#123;</span><br><span class="line">  console.log(&quot;a: &quot; + a + &quot;b: &quot; + b)</span><br><span class="line">&#125;</span><br><span class="line">foo.apply(null, [2,3])</span><br><span class="line"></span><br><span class="line">var bar = foo.bind(null,2);</span><br><span class="line">bar(3);</span><br></pre></td></tr></table></figure></p>
<h4 id="2-6-2-间接引用"><a href="#2-6-2-间接引用" class="headerlink" title="2.6.2 间接引用"></a>2.6.2 间接引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this.a)</span><br><span class="line">&#125;</span><br><span class="line">var a = 2;</span><br><span class="line">var o = &#123;</span><br><span class="line">  a: 3,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line">var p = &#123;</span><br><span class="line">  a: 4</span><br><span class="line">&#125;</span><br><span class="line">o.foo();</span><br><span class="line">(p.foo = o.foo)()</span><br></pre></td></tr></table></figure>
<p>猜猜<code>(p.foo = o.foo)()</code>会返回是什么？<strong>4</strong> ？看来你和我一样错了，应该是<strong>3</strong>。🤷‍♀️。 其实 <code>p.foo = o.foo</code>的返回值是目标函数的引用（对象不拥有函数，忘了？），因此调用位置是<code>foo()</code>而不是<code>p.foo</code>或者<code>o.foo</code>。</p>
<h3 id="2-7-this词法"><a href="#2-7-this词法" class="headerlink" title="2.7 this词法"></a>2.7 this词法</h3><h4 id="2-7-1-箭头函数的this"><a href="#2-7-1-箭头函数的this" class="headerlink" title="2.7.1 箭头函数的this"></a>2.7.1 箭头函数的this</h4><p>箭头函数不使用this的四种标准，而是根据外层作用域来决定this。箭头函数的绑定无法修改，连new也不行。如下是一个箭头函数的使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  return (a) =&gt; &#123;</span><br><span class="line">    console.log(this.a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var obj1 = &#123;</span><br><span class="line">  a: 2</span><br><span class="line">&#125;</span><br><span class="line">var obj2 = &#123;</span><br><span class="line"> a: 3</span><br><span class="line">&#125;</span><br><span class="line">var bar = foo.call(obj1);</span><br><span class="line">bar.call(obj2);</span><br></pre></td></tr></table></figure></p>
<p>foo()的this已经绑定到obj1中，那么bar的this也将指向obj1，箭头函数的绑定无法修改。</p>
<h4 id="2-7-2-回调函数中的箭头函数"><a href="#2-7-2-回调函数中的箭头函数" class="headerlink" title="2.7.2 回调函数中的箭头函数"></a>2.7.2 回调函数中的箭头函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  setTimeout(()=&gt;&#123;</span><br><span class="line">    console.log(this.a)</span><br><span class="line">  &#125;, 100)</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 2</span><br><span class="line">&#125;</span><br><span class="line">foo.call(obj)</span><br></pre></td></tr></table></figure>
<h4 id="2-7-3-ES6之前的替代this的机制："><a href="#2-7-3-ES6之前的替代this的机制：" class="headerlink" title="2.7.3 ES6之前的替代this的机制："></a>2.7.3 ES6之前的替代this的机制：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  var self = this;</span><br><span class="line">  setTimeout(function()&#123;</span><br><span class="line">    console.log(self.a)</span><br><span class="line">  &#125;, 100)</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 2</span><br><span class="line">&#125;;</span><br><span class="line">foo.call(obj);</span><br></pre></td></tr></table></figure></div><!-- comment system--><div class="container"><hr></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div><div class="footer">© 2018 <a href="/" rel="nofollow">polly</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>